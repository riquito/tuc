.\" Automatically generated by Pandoc 2.14.0.3
.\"
.TH "tuc" "1" "Feb 25, 2023" "Tuc 1.0.0" "Tuc Manual"
.hy
.SH NAME
.PP
\f[B]tuc\f[R] \[em] cut text or bytes and keep what you need
.SH SYNOPSIS
.PP
\f[B]tuc\f[R] [FLAGS]\&... [OPTIONS]\&...
.SH DESCRIPTION
.PP
Cut text (or bytes) where a delimiter matches, then keep the desired
parts.
.PP
The data is read from standard input.
.SH FLAGS
.TP
.B \-g, \[en]greedy\-delimiter
Match consecutive delimiters as if it was one
.TP
.B \-p, \[en]compress\-delimiter
Print only the first delimiter of a sequence
.TP
.B \-s, \[en]only\-delimited
Print only lines containing the delimiter
.TP
.B \-V, \[en]version
Print version information
.TP
.B \-z, \[en]zero\-terminated
Line delimiter is NUL (\[rs]0), not LF ()
.TP
.B \-h, \[en]help
Print this help and exit
.TP
.B \-m, \[en]complement
Invert fields (e.g.\ `2' becomes `1,3:')
.TP
.B \-j, \[en](no\-)join
Print selected parts with delimiter in between
.SH OPTIONS
.PP
\f[B]-f\f[R], \f[B]\[en]fields\f[R] [bounds]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Fields to keep, 1-indexed, comma separated.
.PD 0
.P
.PD
\ \ \ \ \ \ \ Use colon to include everything in a range.
.PD 0
.P
.PD
\ \ \ \ \ \ \ Fields can be negative (-1 is the last field).
.PP
\ \ \ \ \ \ \ [default 1:]
.PP
\ \ \ \ \ \ \ e.g.\ cutting on `-' the string `a-b-c-d'
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ 1 => a
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ 1: => a-b-c-d
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ 1:3 => a-b-c
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ 3,2 => cb
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ 3,1:2 => ca-b
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ -3:-2 => b-c
.PP
\ \ \ \ \ \ \ To re-apply the delimiter add -j, to replace
.PD 0
.P
.PD
\ \ \ \ \ \ \ it add -r (followed by the new delimiter)
.PP
\ \ \ \ \ \ \ You can also format the output using {} syntax
.PD 0
.P
.PD
\ \ \ \ \ \ \ e.g.
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ `[\[lq]{1}\[rq], \[lq]{2}\[rq]]' => [\[lq]a\[rq],
\[lq]b\[rq]]
.PP
\ \ \ \ \ \ \ You can escape { and } using {{ and }}.
.PP
\f[B]-b\f[R], \f[B]\[en]bytes\f[R] [bounds]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Same as \[en]fields, but it keeps bytes
.PP
\f[B]-c\f[R], \f[B]\[en]characters\f[R] [bounds]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Same as \[en]fields, but it keeps characters
.PP
\f[B]-l\f[R], \f[B]\[en]lines\f[R] [bounds]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Same as \[en]fields, but it keeps lines
.PD 0
.P
.PD
\ \ \ \ \ \ \ Implies \[en]join.
To merge lines, use \[en]no-join
.PP
\f[B]-d\f[R], \f[B]\[en]delimiter\f[R] [delimiter]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Delimiter used by \[en]fields to cut the text
.PD 0
.P
.PD
\ \ \ \ \ \ \ [default: \[rs]t]
.PP
\f[B]-r\f[R], \f[B]\[en]replace-delimiter\f[R] [new delimiter]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Replace the delimiter with the provided text
.PP
\f[B]-t\f[R], \f[B]\[en]trim\f[R] [type]
.PD 0
.P
.PD
\ \ \ \ \ \ \ Trim the delimiter (greedy).
.PD 0
.P
.PD
\ \ \ \ \ \ \ Valid values are (l|L)eft, (r|R)ight, (b|B)oth
.SH OPTIONS PRECEDENCE
.PP
\[en]trim and \[en]compress-delimiter are applied before \[en]fields or
similar
.SH MEMORY CONSUMPTION
.PP
\[en]characters and \[en]fields read and allocate memory one line at a
time
.PP
\[en]lines allocate memory one line at a time as long as the requested
fields are ordered and non-negative (e.g.\ -l 1,3:4,4,7), otherwise it
allocates the whole input in memory (it also happens when -p or -m are
being used)
.PP
\[en]bytes allocate the whole input in memory
.SH BUGS
.PP
See GitHub Issues: <https://github.com/riquito/tuc/issues>
.SH AUTHOR
.PP
Riccardo Attilio Galli <riccardo@sideralis.org>
.SH SEE ALSO
.PP
\f[B]cut(1)\f[R], \f[B]sed(1)\f[R], \f[B]awk(1)\f[R]
